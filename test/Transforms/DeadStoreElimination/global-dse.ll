; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -basicaa -dse -S | FileCheck %s

define void @simple0(i8* %a) {
; CHECK-LABEL: @simple0(
; CHECK-NEXT:  bb0:
; CHECK-NEXT:    br label [[BB1:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    store i8 undef, i8* [[A:%.*]]
; CHECK-NEXT:    ret void
;
bb0:
  store i8 undef, i8* %a
  br label %bb1
bb1:
  store i8 undef, i8* %a
  ret void
}

define void @simple1_postdom(i8* %a) {
; CHECK-LABEL: @simple1_postdom(
; CHECK-NEXT:  bb0:
; CHECK-NEXT:    br i1 undef, label [[BB1:%.*]], label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    br label [[BB3:%.*]]
; CHECK:       bb2:
; CHECK-NEXT:    br label [[BB3]]
; CHECK:       bb3:
; CHECK-NEXT:    store i8 undef, i8* [[A:%.*]]
; CHECK-NEXT:    ret void
;
bb0:
  br i1 undef, label %bb1, label %bb2
bb1:
  store i8 undef, i8* %a
  br label %bb3
bb2:
  br label %bb3
bb3:
  store i8 undef, i8* %a
  ret void
}

define void @simple2_killed_by_load(i8* %a, i8* %b) {
; CHECK-LABEL: @simple2_killed_by_load(
; CHECK-NEXT:  bb0:
; CHECK-NEXT:    store i8 undef, i8* [[A:%.*]]
; CHECK-NEXT:    br label [[BB1:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    [[TMP:%.*]] = load i8, i8* [[B:%.*]]
; CHECK-NEXT:    store i8 undef, i8* [[A]]
; CHECK-NEXT:    ret void
;
bb0:
  store i8 undef, i8* %a
  br label %bb1
bb1:
  %tmp = load i8, i8* %b
  store i8 undef, i8* %a
  ret void
}

declare void @might_throw()

define void @escaping_dse_blocked_by_maythrow(i8* %a) {
; CHECK-LABEL: @escaping_dse_blocked_by_maythrow(
; CHECK-NEXT:  bb0:
; CHECK-NEXT:    store i8 undef, i8* [[A:%.*]]
; CHECK-NEXT:    br label [[BB1:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    call void @might_throw()
; CHECK-NEXT:    store i8 undef, i8* [[A]]
; CHECK-NEXT:    ret void
;
bb0:
  store i8 undef, i8* %a
  br label %bb1
bb1:
  call void @might_throw()
  store i8 undef, i8* %a
  ret void
}

define i8 @but_nonescaping_can_dse() {
; CHECK-LABEL: @but_nonescaping_can_dse(
; CHECK-NEXT:  bb0:
; CHECK-NEXT:    [[A:%.*]] = alloca i8
; CHECK-NEXT:    br label [[BB1:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    call void @might_throw()
; CHECK-NEXT:    store i8 undef, i8* [[A]]
; CHECK-NEXT:    [[RV:%.*]] = load i8, i8* [[A]]
; CHECK-NEXT:    ret i8 [[RV]]
;
bb0:
  %a = alloca i8
  store i8 undef, i8* %a
  br label %bb1
bb1:
  call void @might_throw()
  store i8 undef, i8* %a
  %rv = load i8, i8* %a
  ret i8 %rv
}

define void @dse_nonescaping_nonreturned() {
; CHECK-LABEL: @dse_nonescaping_nonreturned(
; CHECK-NEXT:  bb0:
; CHECK-NEXT:    br label [[BB1:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    call void @might_throw()
; CHECK-NEXT:    ret void
;
bb0:
  %a = alloca i8
  store i8 undef, i8* %a
  br label %bb1
bb1:
  call void @might_throw()
  store i8 undef, i8* %a
  ret void
}
